[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "태양렬 발전량 예측 자동화",
    "section": "",
    "text": "targets 재현가능 논문작성\n\n\n\n\n웹사이트\nGitHub 저장소\n\n\n\n\n\n\n\n\n\n태양열 발전\n\n\n\n\n탄소중립 신재생에너지 메이커 활동\n\n\n\n\n\n\n\n\n\n작업흐름\n\n\n\n\n\nflowchart TB\n    A[날씨 API] --&gt;|온도 데이터 요청| B(온도 정보 추출)\n    B --&gt;|평균 온도| C{ML 모델}\n    D[(저장된 ML 모델)] --&gt;|모델 로드| C\n    C --&gt;|생산량 예측| E[예측 결과 생성]\n    E --&gt;|예측 데이터| F[이메일 내용 작성]\n    F --&gt;|formatted email| G[SMTP 서버]\n    H[(Gmail 인증 정보)] --&gt;|credentials| G\n    G --&gt;|send email| I[수신자 이메일]\n\n\n\n\n\n\n\n\n프로젝트 구조\nproject_root/\n│\n├── Makefile\n├── data/\n│   └── simple_solar_prediction_model.rds\n├── scripts/\n│   ├── get_weather.R\n│   ├── predict_solar.R\n│   └── send_email.R\n└── output/\n    ├── weather_data.csv\n    ├── temperature.csv\n    └── prediction_result.csv\n\n\nMakefile\n.PHONY: all clean create_dirs\n\nall: send_email\n\noutput/weather_data.csv output/temperature.csv: scripts/get_temperature.R\n    Rscript scripts/get_temperature.R\n\noutput/prediction_result.csv: scripts/predict_solar.R output/weather_data.csv output/temperature.csv\n    Rscript scripts/predict_solar.R\n\nsend_email: scripts/send_email.R output/prediction_result.csv\n    Rscript scripts/send_email.R\n\nclean:\n    rm -f output/weather_data.csv output/temperature.csv output/prediction_result.csv\n\n\n실행결과\n$ make all\nRscript scripts/get_temperature.R\nRscript scripts/get_temperature.R\nRscript scripts/predict_solar.R\nRscript scripts/send_email.R\nThe email message was sent successfully.\n경고메시지(들):\nsprintf(\"=?utf-8?B?%s?=\", base64enc::base64encode(charToRaw(str)), 에서:\n  one argument not used by format '=?utf-8?B?%s?='\n예측 결과가 이메일로 전송되었습니다."
  },
  {
    "objectID": "document/02_ml.html",
    "href": "document/02_ml.html",
    "title": "기계학습",
    "section": "",
    "text": "Solar Power Generation Data 데이터셋은 인도 내 두 지역에서의 태양광 발전량 데이터를 포함하고 있습니다. 데이터는 날씨 조건 및 발전량을 일별로 기록하며, 주어진 기간 동안의 태양광 발전의 효율성을 분석하는 데 사용될 수 있습니다.\n데이터 스키마\n\n\n\n\n\n\n\n\n칼럼명\n자료형\n설명\n\n\n\n\nPLANT_ID\nString\n발전소의 고유 ID\n\n\nSOURCE_KEY\nString\n특정 발전기 또는 인버터의 고유 ID\n\n\nDATE_TIME\nDateTime\n날짜 및 시간 정보\n\n\nDC_POWER\nFloat\n직류(DC) 전력 (kW)\n\n\nAC_POWER\nFloat\n교류(AC) 전력 (kW)\n\n\nDAILY_YIELD\nFloat\n일일 에너지 생성량 (kWh)\n\n\nTOTAL_YIELD\nFloat\n총 에너지 생성량 (kWh)\n\n\nAMBIENT_TEMPERATURE\nFloat\n주변 온도 (°C)\n\n\nMODULE_TEMPERATURE\nFloat\n모듈 온도 (°C)\n\n\nIRRADIATION\nFloat\n태양 복사 강도 (W/m²)"
  },
  {
    "objectID": "document/02_ml.html#ml-예측모형",
    "href": "document/02_ml.html#ml-예측모형",
    "title": "기계학습",
    "section": "ML 예측모형",
    "text": "ML 예측모형\n\n# 필요한 라이브러리 로드\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(tidymodels)\n\n# 데이터 로드\nplant_1_generation &lt;- read_csv(\"data/Plant_1_Generation_Data.csv\")\nplant_1_weather &lt;- read_csv(\"data/Plant_1_Weather_Sensor_Data.csv\")\n\n# 날짜 형식 변환 및 일자별 집계\nplant_1_generation_daily &lt;- plant_1_generation %&gt;%\n  mutate(DATE = dmy_hm(DATE_TIME)) %&gt;%\n  group_by(DATE = as.Date(DATE)) %&gt;%\n  summarise(\n    DAILY_YIELD = sum(DAILY_YIELD),\n    TOTAL_YIELD = max(TOTAL_YIELD),\n    DC_POWER = mean(DC_POWER),\n    AC_POWER = mean(AC_POWER)\n  )\n\nplant_1_weather_daily &lt;- plant_1_weather %&gt;%\n  group_by(DATE = as.Date(DATE_TIME)) %&gt;%\n  summarise(\n    AMBIENT_TEMPERATURE = mean(AMBIENT_TEMPERATURE),\n    MODULE_TEMPERATURE = mean(MODULE_TEMPERATURE),\n    IRRADIATION = sum(IRRADIATION)  # 일일 총 일사량\n  )\n\n# 데이터 결합\nplant_1_combined &lt;- plant_1_generation_daily %&gt;%\n  inner_join(plant_1_weather_daily, by = \"DATE\") %&gt;%\n  mutate(\n    DAY = day(DATE),\n    MONTH = month(DATE),\n    DAY_OF_WEEK = wday(DATE)\n  )\n\n# 결측치 처리\nplant_1_combined &lt;- na.omit(plant_1_combined)\n\n# 변수 정의\nweather_features &lt;- c(\"AMBIENT_TEMPERATURE\", \"MODULE_TEMPERATURE\", \"IRRADIATION\")\ntime_features &lt;- c(\"DAY\", \"MONTH\", \"DAY_OF_WEEK\")\ntarget &lt;- \"DAILY_YIELD\"\n\n# 데이터 분할\nset.seed(123)\ndata_split &lt;- initial_split(plant_1_combined, prop = 0.7, strata = DAILY_YIELD)\ntrain_data &lt;- training(data_split)\ntest_data &lt;- testing(data_split)\n\nprint(paste(\"단순 분할 - 훈련 데이터 크기:\", nrow(train_data)))\nprint(paste(\"단순 분할 - 테스트 데이터 크기:\", nrow(test_data)))\n\n# 레시피 정의\nsolar_recipe &lt;- recipe(DAILY_YIELD ~ ., data = train_data) %&gt;%\n  step_rm(DATE, TOTAL_YIELD) %&gt;%\n  step_normalize(all_predictors()) %&gt;%\n  step_zv(all_predictors())\n\n# 모델 정의 (Random Forest)\nrf_model &lt;- rand_forest(mtry = tune(), min_n = tune(), trees = 500) %&gt;%\n  set_engine(\"ranger\", importance = \"permutation\") %&gt;%\n  set_mode(\"regression\")\n\n# 워크플로우 정의\nsolar_workflow &lt;- workflow() %&gt;%\n  add_recipe(solar_recipe) %&gt;%\n  add_model(rf_model)\n\n# 교차 검증 폴드 정의\ncv_folds &lt;- vfold_cv(train_data, v = 5)\n\n# 하이퍼파라미터 튜닝\ntuning_results &lt;- tune_grid(\n  solar_workflow,\n  resamples = cv_folds,\n  grid = 20\n)\n\n# 최적 하이퍼파라미터 선택\nbest_params &lt;- select_best(tuning_results, \"rmse\")\n\n# 최종 워크플로우 구성\nfinal_workflow &lt;- solar_workflow %&gt;%\n  finalize_workflow(best_params)\n\n# 최종 모델 학습\nfinal_model &lt;- fit(final_workflow, data = train_data)\n\n# 테스트 데이터에 대한 예측\npredictions &lt;- predict(final_model, new_data = test_data)\nresults &lt;- test_data %&gt;%\n  select(DAILY_YIELD) %&gt;%\n  bind_cols(predictions)\n\n# 모델 성능 평가\nmetrics &lt;- metric_set(rmse, rsq, mae)\nmodel_performance &lt;- metrics(results, truth = DAILY_YIELD, estimate = .pred)\nprint(model_performance)\n\n# 변수 중요도 계산\nimportance &lt;- final_model %&gt;%\n  extract_fit_parsnip() %&gt;%\n  vip::vip(num_features = 10)\n\n# 변수 중요도 시각화\nimportance_plot &lt;- importance +\n  geom_col(aes(fill = Variable %in% weather_features)) +\n  scale_fill_manual(values = c(\"grey\", \"red\"), \n                    labels = c(\"Time Features\", \"Weather Features\")) +\n  labs(fill = \"Feature Type\") +\n  theme_minimal() +\n  labs(title = \"Top 10 Variable Importance (Weather variables in red)\")\n\nprint(importance_plot)\n\n# 실제값 vs 예측값 산점도\nprediction_plot &lt;- ggplot(results, aes(x = DAILY_YIELD, y = .pred)) +\n  geom_point(alpha = 0.3) +\n  geom_abline(color = \"red\", linetype = \"dashed\") +\n  labs(x = \"Actual Daily Yield\", y = \"Predicted Daily Yield\", \n       title = \"Actual vs Predicted Daily Yield\") +\n  theme_minimal()\n\nprint(prediction_plot)\n\n# 날씨 변수와 발전량의 관계 시각화\nweather_plots &lt;- map(weather_features, function(feature) {\n  ggplot(train_data, aes_string(x = feature, y = target)) +\n    geom_point(alpha = 0.1) +\n    geom_smooth(method = \"lm\", color = \"red\") +\n    labs(title = paste(feature, \"vs\", target)) +\n    theme_minimal()\n})\n\nprint(weather_plots)\n\n# 모델 저장\nsaveRDS(final_model, \"data/solar_power_prediction_model.rds\")"
  },
  {
    "objectID": "document/02_ml.html#단순-회귀모형",
    "href": "document/02_ml.html#단순-회귀모형",
    "title": "기계학습",
    "section": "단순 회귀모형",
    "text": "단순 회귀모형\n\nplant_1_combined |&gt; \n  ggplot(aes(x = AMBIENT_TEMPERATURE, y = IRRADIATION)) +\n    geom_point() +\n    geom_smooth(method = \"lm\", color = \"red\") \n\n\n# 데이터 분할 (시계열 특성을 고려하여 날짜 순으로 분할)\nplant_1_combined &lt;- plant_1_combined %&gt;% \n  arrange(DATE)\n\ntrain_data &lt;- plant_1_combined %&gt;% slice(1:round(0.7 * nrow(plant_1_combined)))\ntest_data &lt;- plant_1_combined %&gt;% slice((round(0.7 * nrow(plant_1_combined)) + 1):nrow(plant_1_combined))\n\n# 단순 선형 회귀 모델 생성\nsimple_model &lt;- lm(DAILY_YIELD ~ AMBIENT_TEMPERATURE, data = train_data)\n\n# 모델 요약\nsummary(simple_model)\n\n# 테스트 데이터에 대한 예측\npredictions &lt;- predict(simple_model, newdata = test_data)\n\n# 모델 성능 평가\nrmse &lt;- sqrt(mean((test_data$DAILY_YIELD - predictions)^2))\nr_squared &lt;- cor(test_data$DAILY_YIELD, predictions)^2\n\ncat(\"RMSE:\", rmse, \"\\n\")\ncat(\"R-squared:\", r_squared, \"\\n\")\n\n# 실제값 vs 예측값 산점도\nggplot(data = test_data, aes(x = DAILY_YIELD, y = predictions)) +\n  geom_point() +\n  geom_abline(intercept = 0, slope = 1, color = \"red\", linetype = \"dashed\") +\n  labs(x = \"Actual Daily Yield\", y = \"Predicted Daily Yield\",\n       title = \"Actual vs Predicted Daily Yield\") +\n  theme_minimal()\n\n# AMBIENT_TEMPERATURE와 DAILY_YIELD의 관계 시각화\nggplot(data = plant_1_combined, aes(x = AMBIENT_TEMPERATURE, y = DAILY_YIELD)) +\n  geom_point(alpha = 0.5) +\n  geom_smooth(method = \"lm\", color = \"red\") +\n  labs(x = \"Ambient Temperature\", y = \"Daily Yield\",\n       title = \"Ambient Temperature vs Daily Yield\") +\n  theme_minimal()\n\n# 모델 저장\nsaveRDS(simple_model, \"data/simple_solar_prediction_model.rds\")"
  },
  {
    "objectID": "document/01_weather.html",
    "href": "document/01_weather.html",
    "title": "날씨 API",
    "section": "",
    "text": "날씨 API\n기상청_단기예보 ((구)_동네예보) 조회서비스 API는 초단기실황, 초단기예보, 단기((구)동네)예보, 예보버전 정보를 조회하는 서비스입니다. 초단기실황정보는 예보 구역에 대한 대표 AWS 관측값을, 초단기예보는 예보시점부터 6시간까지의 예보를, 단기예보는 예보기간을 글피까지 확장 및 예보단위를 상세화(3시간→1시간)하여 시공간적으로 세분화한 예보를 제공합니다.\n제공되는 API 문서에서 세종대학교 해당 좌표(nx, ny)를 특정하고 해당 좌표의 날씨 정보를 조회하는 코드를 작성한다.\n\n# Load required libraries\nlibrary(httr2)\nlibrary(xml2)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# Set API information\nservice_key &lt;- Sys.getenv(\"DATA_GO_DECODE_KEY\")  # Your decoded service key\nbase_date &lt;- str_remove_all(Sys.Date(), \"-\") # \"20240628\"  # Forecast base date (YYYYMMDD format)\nbase_time &lt;- \"0500\"      # Forecast base time (HHMM format)\nnx &lt;- 62                 # X coordinate for Seoul Gwangjin-gu Gunja-dong (Sejong University)\nny &lt;- 126                # Y coordinate for Seoul Gwangjin-gu Gunja-dong (Sejong University)\n\n# Make API request\nresp &lt;- request(\"http://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst\") |&gt; \n  req_url_query(\n    serviceKey = service_key,\n    pageNo = \"1\",\n    numOfRows = \"1000\",\n    dataType = \"XML\",\n    base_date = base_date,\n    base_time = base_time,\n    nx = nx,\n    ny = ny\n  ) |&gt; \n  req_perform()\n\n# Parse XML response\nxml_data &lt;- resp |&gt; resp_body_xml()\n\n# Extract items\nitems &lt;- xml_find_all(xml_data, \"//item\")\n\n# Convert to data frame\nforecast_data &lt;- map_df(items, ~{\n  data.frame(\n    baseDate = xml_text(xml_find_first(.x, \".//baseDate\")),\n    baseTime = xml_text(xml_find_first(.x, \".//baseTime\")),\n    category = xml_text(xml_find_first(.x, \".//category\")),\n    fcstDate = xml_text(xml_find_first(.x, \".//fcstDate\")),\n    fcstTime = xml_text(xml_find_first(.x, \".//fcstTime\")),\n    fcstValue = xml_text(xml_find_first(.x, \".//fcstValue\"))\n  )\n})\n\n# Reshape data\nforecast_tbl &lt;- forecast_data %&gt;%\n  pivot_wider(names_from = category, values_from = fcstValue)\n\n# Print the first few rows of the resulting data\ntemperature &lt;- forecast_tbl |&gt; \n  mutate(fcstDate = ymd(fcstDate)) |&gt; \n  filter(fcstDate == min(fcstDate)) |&gt; \n  mutate(TMP = as.numeric(TMP)) |&gt;\n  summarise(평균온도 = mean(TMP)) |&gt; \n  pull(평균온도)\n\nprint(temperature)\n\n[1] 28.33333"
  },
  {
    "objectID": "document/03_email.html",
    "href": "document/03_email.html",
    "title": "전자우편 발송",
    "section": "",
    "text": "# 필요한 라이브러리 로드\nlibrary(tidyverse)\nlibrary(blastula)\n\n# 저장된 모델 불러오기\nsimple_model &lt;- readRDS(\"data/simple_solar_prediction_model.rds\")\n\n# 온도를 입력받아 일일 생산량을 예측하는 함수\npredict_yield &lt;- function(temperature) {\n  new_data &lt;- data.frame(AMBIENT_TEMPERATURE = temperature)\n  predicted &lt;- predict(simple_model, newdata = new_data)\n  return(predicted)\n}\n\n# 사용자로부터 온도 입력 받기\ncat(\"예상 기온을 입력하세요 (°C): \")\nuser_temperature &lt;- 10\n\n# 예측 수행\npredicted_yield &lt;- predict_yield(user_temperature)\n\n# 신뢰 구간 계산\nnew_data &lt;- data.frame(AMBIENT_TEMPERATURE = user_temperature)\nprediction_interval &lt;- predict(simple_model, newdata = new_data, interval = \"prediction\")\n\n# 예측 결과 시각화\ntemp_range &lt;- seq(user_temperature - 10, user_temperature + 10, by = 0.5)\nprediction_data &lt;- data.frame(AMBIENT_TEMPERATURE = temp_range)\nprediction_data$PREDICTED_YIELD &lt;- predict(simple_model, newdata = prediction_data)"
  },
  {
    "objectID": "document/03_email.html#gmail-앱-비밀번호",
    "href": "document/03_email.html#gmail-앱-비밀번호",
    "title": "전자우편 발송",
    "section": "Gmail 앱 비밀번호",
    "text": "Gmail 앱 비밀번호\nblastula 구글메일 설정 Sending Email Using SMTP방법은 다음과 같다.\n\nGoogle 계정에 로그인합니다.\n보안 섹션으로 이동합니다.\n2단계 인증이 활성화되어 있는지 확인합니다. 그렇지 않으면 먼저 활성화해야 합니다.\n“앱 비밀번호” 섹션에서 새로운 앱 비밀번호를 생성합니다. (앱 유형과 디바이스는 사용자 지정할 수 있습니다.)\n\n\n\n\n\n\n\n# Create a credentials file for sending\n# email through Gmail\ncreate_smtp_creds_file(\n  file = \"gmail_creds\",\n  user = \"kwangchun.lee.7@gmail.com\",\n  provider = \"gmail\",\n  use_ssl = TRUE\n)\n\ntest_message &lt;- prepare_test_message()\ntest_message\n\ntest_message %&gt;%\n  smtp_send(\n    from = \"kwangchun.lee.7@email.net\",\n    to = \"victor@r2bit.com\",\n    subject = \"Testing the `smtp_send()` function\",\n    credentials = creds_file(file = \"gmail_creds\")\n  )"
  },
  {
    "objectID": "document/03_email.html#이메일-전송",
    "href": "document/03_email.html#이메일-전송",
    "title": "전자우편 발송",
    "section": "이메일 전송",
    "text": "이메일 전송\n\n# 이메일 내용 작성\nemail_body &lt;- compose_email(\n  body = md(glue::glue(\"\n    # 태양광 발전량 예측 보고서\n\n    예상 기온: {user_temperature}°C\n\n    예측된 일일 생산량: {round(predicted_yield, 2)}\n\n    95% 예측 구간: {round(prediction_interval[1,'lwr'], 2)} - {round(prediction_interval[1,'upr'], 2)}\n\n  \"))\n)\n\n# # 환경설정 - 앱 비밀번호 16자리 사용 (1번만 수행)\n# create_smtp_creds_file(\n#   file = \"gmail_creds\",\n#   user = \"kwangchun.lee.7@gmail.com\",\n#   provider = \"gmail\",\n#   host = \"smtp.gmail.com\",\n#   port = 465,\n#   use_ssl = TRUE\n# )\n\n# Gmail 자격 증명 불러오기\ncreds &lt;- creds_file(\"gmail_creds\")\n\n# 이메일 전송\nemail_body |&gt; \n  smtp_send(\n    from = \"kwangchun.lee.7@gmail.com\",\n    to = \"victor@r2bit.com\",\n    subject = \"태양광 발전량 예측 보고서\",\n    credentials = creds\n  )\n\ncat(\"예측 결과가 이메일로 전송되었습니다.\\n\")"
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "리눅스 환경설정",
    "section": "",
    "text": "윈도우 10 - WSL (우분투 배쉬)\n\nWSL(Windows Subsystem for Linux)을 사용하여 Ubuntu를 설치하는 방법은 다음과 같다.\n\nWindows 기능 활성화:\n\nWindows 검색창에 “Windows 기능 켜기/끄기”를 입력하고 실행합니다.\n“Linux용 Windows 하위 시스템”을 체크하고 확인을 누릅니다.\n컴퓨터를 재시작합니다.\n\nMicrosoft Store 열기:\n\nWindows 검색창에 “Microsoft Store”를 입력하고 실행합니다.\n\n\nUbuntu 검색 및 설치:\n\nStore에서 “Ubuntu”를 검색합니다.\n원하는 Ubuntu 버전(예: Ubuntu 20.04 LTS)을 선택합니다.\n“설치” 버튼을 클릭합니다.\n\nUbuntu 실행:\n\n설치가 완료되면 “실행” 버튼을 클릭하거나,\n시작 메뉴에서 Ubuntu를 찾아 실행합니다.\n\n초기 설정:\n\n처음 실행 시 새 UNIX 사용자 이름과 비밀번호를 설정합니다.\n\n\n이제 WSL을 통해 Ubuntu를 사용할 수 있습니다. 터미널에서 Linux 명령어를 실행할 수 있으며, Windows 파일 시스템에도 접근 가능합니다."
  },
  {
    "objectID": "setup.html#bashrc-설정",
    "href": "setup.html#bashrc-설정",
    "title": "리눅스 환경설정",
    "section": ".bashrc 설정",
    "text": ".bashrc 설정\n일반적으로 쉘에서 export 명령어로 설정한 환경변수는 현재 세션에서만 유지되며, 시스템을 재부팅하면 사라집니다. 이는 임시적인 설정 방법입니다.\n재부팅 후에도 환경변수를 유지하려면, 다음과 같은 방법을 사용할 수 있습니다:\n\n쉘 구성 파일에 추가: 사용하는 쉘에 따라 적절한 구성 파일에 환경변수를 추가합니다.\n\n\nBash를 사용하는 경우 (~/.bashrc 또는 ~/.bash_profile):\n\n# 기존 .bashrc 또는 .bash_profile 파일의 끝에 다음 줄을 추가\nexport DATA_GO_ENCODE_KEY='GQMNLxxxx'\nexport DATA_GO_DECODE_KEY='GQMNLxxxx'\n\nZsh를 사용하는 경우 (~/.zshrc):\n\n# 기존 .zshrc 파일의 끝에 다음 줄을 추가\nexport DATA_GO_ENCODE_KEY='GQMNLxxxx'\nexport DATA_GO_DECODE_KEY='GQMNLxxxx'\n\n시스템 전체 환경변수 설정:\n\n모든 사용자에게 적용되는 시스템 전체 환경변수를 설정하려면 /etc/environment 파일을 수정합니다.\n# /etc/environment 파일에 다음 줄을 추가 (root 권한 필요)\nDATA_GO_ENCODE_KEY=GQMNLxxxx\nDATA_GO_DECODE_KEY=GQMNLxxxx\n\n사용자 지정 환경변수 파일 생성:\n\n/etc/profile.d/ 디렉토리에 사용자 지정 스크립트를 만들어 환경변수를 설정할 수 있습니다.\n# /etc/profile.d/my_env_vars.sh 파일 생성 (root 권한 필요)\n#!/bin/bash\nexport DATA_GO_ENCODE_KEY='GQMNLxxxx'\nexport DATA_GO_DECODE_KEY='GQMNLxxxx'\n이러한 방법들을 사용하면 시스템을 재부팅한 후에도 환경변수가 유지됩니다. 변경 사항을 적용하려면 시스템을 재부팅하거나, 해당 구성 파일을 다시 불러와야 합니다 (예: source ~/.bashrc)."
  }
]